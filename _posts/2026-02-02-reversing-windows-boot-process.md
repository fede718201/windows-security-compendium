---
layout: post
slug: reversing_windows_boot_chain
title: Reversing the Windows Boot Chain with Binary Ninja
---

I've read probably every blog post and book chapter about the Windows boot process at this point, and they all say the same thing. "BIOS initializes hardware, bootloader loads the kernel, Windows starts." That's not wrong, but it tells you nothing. I wanted to know what actually executes. Like, what is the CPU doing in the first millisecond? What's sitting in RCX when the kernel entry point gets called? None of the resources I found went there, so I figured I'd just look at the code myself. Threw `ntoskrnl.exe` into Binary Ninja, grabbed the PDB from Microsoft's symbol server, and started scrolling.

Before I get into the kernel though, quick rundown of everything that happens before `KiSystemStartup` even runs. Pressing the power button literally just shorts two pins together (PWRBTN# and GND). The PCH picks that up, runs through the power-on sequence, waits for PWR_OK from the PSU, releases the CPU from reset. CPU wakes up and fetches its first instruction from `0xFFFFFFF0`, the chipset maps that address to the UEFI firmware on the SPI flash. Then you get the firmware phases back to back: SEC has to do this wild trick called Cache-As-RAM because there's no DRAM yet (the cache literally pretends to be memory), PEI actually initializes RAM through Intel/AMD's proprietary Memory Reference Code, DXE spins up all the firmware drivers, BDS figures out what to boot. It finds `bootmgfw.efi` on the EFI System Partition, which reads the BCD, and yeah, the BCD is just a registry hive sitting on FAT32, kind of cursed if you think about it. It does the TPM measurements for BitLocker, then loads `winload.efi`. That's the big one. `winload.efi` pulls in `ntoskrnl.exe`, `hal.dll`, all the BOOT_START drivers, builds the `LOADER_PARAMETER_BLOCK` (memory map, every loaded module, initial EPROCESS and ETHREAD, the SYSTEM hive, tons more), configures the page tables, drops the PML4 into CR3, sets up a GDT and IDT, calls `ExitBootServices()`, and that's it, UEFI is gone, no going back. Pointer to the LOADER_PARAMETER_BLOCK goes into RCX, jump to `KiSystemStartup`.

That's where we pick up.

My lab is a Windows 11 VM running on KVM/QEMU, host is Ubuntu, kernel debug over virtual serial. I check every structure offset against the PDB using [pdbkit](https://github.com/fede718201/pdbkit), a tool I wrote for pulling type info straight from Microsoft's symbol files. Your offsets will be different if you're on a different build, but the logic is the same. Load the binary, import the PDB, and you'll see what I'm seeing.
