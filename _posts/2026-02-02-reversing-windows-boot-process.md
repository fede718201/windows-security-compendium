---
layout: post
slug: reversing_windows_boot_chain
title: Reversing the Windows Boot Chain with Binary Ninja
---

Before getting into the kernel code, here is a compressed version of what happens before `KiSystemStartup` runs. I am not going to spend too much time on the pre-kernel stages since the focus of this post is on `ntoskrnl.exe` itself, but some context is necessary.

Pressing the power button shorts PWRBTN# to GND on the motherboard. That is the entire input. The PCH's Power Management Controller picks up the falling edge, sequences the sleep signals and PS_ON#, waits for PWR_OK from the PSU, and releases the CPU from reset. First instruction fetch lands at `0xFFFFFFF0`. The chipset routes that address to the SPI flash where the UEFI firmware lives.

The firmware side of things is a whole topic on its own, but the short version: SEC runs first and has to set up Cache-As-RAM because DRAM does not exist yet (the CPU cache is literally tricked into acting as writable memory). PEI comes next and its main job is getting real RAM working through the Memory Reference Code. DXE is where the firmware starts resembling an OS, loading drivers and building the UEFI service tables. BDS finds the boot device.

From there it is the Windows bootloader chain. `bootmgfw.efi` reads the BCD store, which is a registry hive sitting on FAT32 if you can believe that, takes TPM measurements, and loads `winload.efi`. This is the component that does the real work. `winload.efi` loads `ntoskrnl.exe`, `hal.dll`, all the BOOT_START drivers, and builds the `LOADER_PARAMETER_BLOCK`. That structure is massive. Physical memory map, every loaded module, initial EPROCESS, initial ETHREAD, the SYSTEM hive, boot flags, ELAM data, TPM entropy. Everything. `winload.efi` also configures the page tables, writes PML4 into CR3, sets up the GDT and IDT, then calls `ExitBootServices()`. After that call the firmware is gone. No going back. The LOADER_PARAMETER_BLOCK pointer goes into RCX and execution jumps to `KiSystemStartup`.

## KiSystemStartup

This is where the kernel takes over. `KiSystemStartup` is the entry point of `ntoskrnl.exe`, the very first kernel function that executes after `winload.efi` transfers control. Everything before this point was firmware or bootloader code. From here on, the kernel owns the machine. The function signature is simple: a single `void*` parameter called `LoaderBlock`, passed in `rcx` per the Windows x64 calling convention.

![1](/assets/images/1.png)

The prologue opens with `sub rsp, 0x38`, which allocates 56 bytes on the stack. This is standard for Windows x64 functions. 32 of those bytes are the shadow space, a mandatory region that the calling convention reserves so the callee can spill the four register-passed arguments (`rcx`, `rdx`, `r8`, `r9`) if it needs to. The remaining 24 bytes are for local variables. Even though `KiSystemStartup` only takes one argument, the shadow space is always 32 bytes because it is the callee's job to provide it for any functions it calls downstream.

The next instruction, `mov qword [rsp+0x30], r15`, saves the contents of `r15` onto the stack. `r15` is a non-volatile register in the Windows x64 ABI, meaning any function that uses it must restore its original value before returning. The kernel is about to repurpose `r15` for its own use, so it preserves the caller's value at offset `rsp+0x30`, which is the last 8-byte slot in the allocated frame (0x38 minus 0x8). This is followed by `mov r15, rsp`, which copies the current stack pointer into `r15`. This effectively turns `r15` into a frame pointer. The function can now reference its local variables and saved state relative to `r15` regardless of any subsequent stack manipulation. This is a pattern you see frequently in kernel code where the stack pointer might be modified by nested calls or interrupt handling, and having a stable reference point matters.

Then comes the most important line in this prologue: `mov qword [rel KeLoaderBlock], rcx`. The `rcx` register holds the first argument to the function, which is the `LoaderBlock` pointer. This instruction stores that pointer into `KeLoaderBlock`, a global variable inside `ntoskrnl.exe`. This is a critical design decision. `winload.efi` spent a significant amount of effort constructing the `LOADER_PARAMETER_BLOCK`, filling it with the physical memory map, the list of every loaded module, the initial process and thread structures, the SYSTEM registry hive, boot flags, TPM entropy, ELAM data, and more. By saving the pointer globally, the kernel makes all of that information available to every subsystem that initializes after this point. Throughout Phase 0 initialization, you will see function after function either taking `KeLoaderBlock` as an argument or reading it directly. It is the single source of truth about the state of the machine at handoff.

The next two instructions perform a validation check. `mov r10, qword [rcx+0x88]` dereferences the `LoaderBlock` at offset 0x88. In the `LOADER_PARAMETER_BLOCK` structure, this offset corresponds to the `Extension` field, which is a pointer to a `LOADER_PARAMETER_EXTENSION`. This extension structure contains additional boot environment metadata that did not fit in the base structure: the firmware version, performance counter data, hypervisor configuration, and various feature flags. The kernel then executes `cmp dword [r10+0x24], 0x0`, which tests a 32-bit value at offset 0x24 inside the extension. This is a size or version field that the kernel uses to validate that the extension is well-formed. If `winload.efi` produced a corrupted or incompatible extension, this field would be zero. The `jne 0x140b3b3cd` that follows jumps to the normal initialization path if the value is non-zero, meaning the extension is valid. If the value is zero, execution falls through into what is almost certainly a `KeBugCheck` call. The kernel refuses to boot on bad bootloader data. There is no recovery path. This is the first of many sanity checks that the kernel performs during early initialization, and it happens before anything else because every subsystem downstream depends on the integrity of the `LOADER_PARAMETER_BLOCK`.
